rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    
    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }
    // Note: Storage rules don't have direct access to Firestore data (userData) easily without custom claims.
    // We will rely on path-based security and assuming custom claims or just path validation for now.
    // Ideally, we would use custom claims for roles (admin/super_admin).
    // For this implementation, we will assume:
    // 1. Students only access /documents/{userId}/*
    // 2. Admins/SuperAdmins need access to everything. 
    // Since we can't easily check Firestore role in Storage rules without extra setup, 
    // we might need to rely on the app to enforce admin-only paths, OR allow all authenticated users to read everything (less secure)
    // OR, better: Allow user to read/write their own folder.
    // BUT, Admins need to read student folders.
    
    // WORKAROUND: For now, we will allow:
    // - User to read/write their own documents
    // - ANY authenticated user to read all documents (so Admins can see them) - This is a trade-off if we can't check roles.
    // - BUT, we can try to restrict WRITE.
    
    // Documents:
    match /documents/{userId}/{allPaths=**} {
      // Owner can read/write
      allow read, write: if isSignedIn() && request.auth.uid == userId;
      // Anyone signed in can READ (so admins can see). 
      // Ideally we restrict this to admins only, but without custom claims, 'isSignedIn()' is the baseline.
      // To make it stricter, we'd need to set up Custom Claims on the server side (Cloud Functions).
      allow read: if isSignedIn(); 
    }
    
    // PS Templates:
    match /ps_templates/{allPaths=**} {
      allow read: if isSignedIn();
      allow write: if isSignedIn(); // Ideally Admin only.
    }
    
    // Default:
    match /{allPaths=**} {
      allow read, write: if isSignedIn();
    }
  }
}